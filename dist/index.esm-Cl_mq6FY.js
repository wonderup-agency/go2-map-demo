const t=t=>{var e,r,s,n="google",o="importLibrary",i="__ib__",a=document,c=window,u=c[n]||(c[n]={}),l=u.maps||(u.maps={}),h=new Set,p=new URLSearchParams;l[o]||(l[o]=(c,...u)=>h.add(c)&&(e||(e=new Promise(async(o,c)=>{for(s in await(r=a.createElement("script")),p.set("libraries",[...h]+""),t)p.set(s.replace(/[A-Z]/g,t=>"_"+t[0].toLowerCase()),t[s]);p.set("callback",n+".maps."+i),function(t,e){t.src=e}(r,"https://maps.googleapis.com/maps/api/js?"+p),l[i]=o,r.onerror=()=>e=c(Error("The Google Maps JavaScript API could not load.")),r.nonce=a.querySelector("script[nonce]")?.nonce||"",a.head.append(r)}))).then(()=>l[o](c,...u)))};let e=!1;function r(r){e?(t=>{JSON.stringify(t)})(r):(!function(e){const r=Boolean(window.google?.maps?.importLibrary);r&&(t=>{JSON.stringify(t)})(e);r||t(e)}(r),e=!0)}async function s(t){if(!window?.google?.maps?.importLibrary)throw new Error("google.maps.importLibrary is not installed.");return await google.maps.importLibrary(t)}const{getOwnPropertyNames:n,getOwnPropertySymbols:o}=Object,{hasOwnProperty:i}=Object.prototype;function a(t,e){return function(r,s,n){return t(r,s,n)&&e(r,s,n)}}function c(t){return function(e,r,s){if(!e||!r||"object"!=typeof e||"object"!=typeof r)return t(e,r,s);const{cache:n}=s,o=n.get(e),i=n.get(r);if(o&&i)return o===r&&i===e;n.set(e,r),n.set(r,e);const a=t(e,r,s);return n.delete(e),n.delete(r),a}}function u(t){return n(t).concat(o(t))}const l=Object.hasOwn||((t,e)=>i.call(t,e));function h(t,e){return t===e||!t&&!e&&t!=t&&e!=e}const{getOwnPropertyDescriptor:p,keys:f}=Object;function m(t,e){return t.byteLength===e.byteLength&&C(new Uint8Array(t),new Uint8Array(e))}function d(t,e,r){let s=t.length;if(e.length!==s)return!1;for(;s-- >0;)if(!r.equals(t[s],e[s],s,s,t,e,r))return!1;return!0}function g(t,e){return t.byteLength===e.byteLength&&C(new Uint8Array(t.buffer,t.byteOffset,t.byteLength),new Uint8Array(e.buffer,e.byteOffset,e.byteLength))}function y(t,e){return h(t.getTime(),e.getTime())}function b(t,e){return t.name===e.name&&t.message===e.message&&t.cause===e.cause&&t.stack===e.stack}function w(t,e){return t===e}function k(t,e,r){const s=t.size;if(s!==e.size)return!1;if(!s)return!0;const n=new Array(s),o=t.entries();let i,a,c=0;for(;(i=o.next())&&!i.done;){const s=e.entries();let o=!1,u=0;for(;(a=s.next())&&!a.done;){if(n[u]){u++;continue}const s=i.value,l=a.value;if(r.equals(s[0],l[0],c,u,t,e,r)&&r.equals(s[1],l[1],s[0],l[0],t,e,r)){o=n[u]=!0;break}u++}if(!o)return!1;c++}return!0}const E=h;function M(t,e,r){const s=f(t);let n=s.length;if(f(e).length!==n)return!1;for(;n-- >0;)if(!L(t,e,r,s[n]))return!1;return!0}function A(t,e,r){const s=u(t);let n,o,i,a=s.length;if(u(e).length!==a)return!1;for(;a-- >0;){if(n=s[a],!L(t,e,r,n))return!1;if(o=p(t,n),i=p(e,n),(o||i)&&(!o||!i||o.configurable!==i.configurable||o.enumerable!==i.enumerable||o.writable!==i.writable))return!1}return!0}function _(t,e){return h(t.valueOf(),e.valueOf())}function x(t,e){return t.source===e.source&&t.flags===e.flags}function v(t,e,r){const s=t.size;if(s!==e.size)return!1;if(!s)return!0;const n=new Array(s),o=t.values();let i,a;for(;(i=o.next())&&!i.done;){const s=e.values();let o=!1,c=0;for(;(a=s.next())&&!a.done;){if(!n[c]&&r.equals(i.value,a.value,i.value,a.value,t,e,r)){o=n[c]=!0;break}c++}if(!o)return!1}return!0}function C(t,e){let r=t.byteLength;if(e.byteLength!==r||t.byteOffset!==e.byteOffset)return!1;for(;r-- >0;)if(t[r]!==e[r])return!1;return!0}function j(t,e){return t.hostname===e.hostname&&t.pathname===e.pathname&&t.protocol===e.protocol&&t.port===e.port&&t.hash===e.hash&&t.username===e.username&&t.password===e.password}function L(t,e,r,s){return!("_owner"!==s&&"__o"!==s&&"__v"!==s||!t.$$typeof&&!e.$$typeof)||l(e,s)&&r.equals(t[s],e[s],s,s,t,e,r)}const O={"[object Int8Array]":!0,"[object Uint8Array]":!0,"[object Uint8ClampedArray]":!0,"[object Int16Array]":!0,"[object Uint16Array]":!0,"[object Int32Array]":!0,"[object Uint32Array]":!0,"[object Float16Array]":!0,"[object Float32Array]":!0,"[object Float64Array]":!0,"[object BigInt64Array]":!0,"[object BigUint64Array]":!0},q=Object.prototype.toString;function I({areArrayBuffersEqual:t,areArraysEqual:e,areDataViewsEqual:r,areDatesEqual:s,areErrorsEqual:n,areFunctionsEqual:o,areMapsEqual:i,areNumbersEqual:a,areObjectsEqual:c,arePrimitiveWrappersEqual:u,areRegExpsEqual:l,areSetsEqual:h,areTypedArraysEqual:p,areUrlsEqual:f,unknownTagComparators:m}){return function(d,g,y){if(d===g)return!0;if(null==d||null==g)return!1;const b=typeof d;if(b!==typeof g)return!1;if("object"!==b)return"number"===b?a(d,g,y):"function"===b&&o(d,g,y);const w=d.constructor;if(w!==g.constructor)return!1;if(w===Object)return c(d,g,y);if(Array.isArray(d))return e(d,g,y);if(w===Date)return s(d,g,y);if(w===RegExp)return l(d,g,y);if(w===Map)return i(d,g,y);if(w===Set)return h(d,g,y);const k=q.call(d);if("[object Date]"===k)return s(d,g,y);if("[object RegExp]"===k)return l(d,g,y);if("[object Map]"===k)return i(d,g,y);if("[object Set]"===k)return h(d,g,y);if("[object Object]"===k)return"function"!=typeof d.then&&"function"!=typeof g.then&&c(d,g,y);if("[object URL]"===k)return f(d,g,y);if("[object Error]"===k)return n(d,g,y);if("[object Arguments]"===k)return c(d,g,y);if(O[k])return p(d,g,y);if("[object ArrayBuffer]"===k)return t(d,g,y);if("[object DataView]"===k)return r(d,g,y);if("[object Boolean]"===k||"[object Number]"===k||"[object String]"===k)return u(d,g,y);if(m){let t=m[k];if(!t){const e=null!=(E=d)?E[Symbol.toStringTag]:void 0;e&&(t=m[e])}if(t)return t(d,g,y)}var E;return!1}}const P=S();function S(t={}){const{circular:e=!1,createInternalComparator:r,createState:s,strict:n=!1}=t,o=function({circular:t,createCustomConfig:e,strict:r}){let s={areArrayBuffersEqual:m,areArraysEqual:r?A:d,areDataViewsEqual:g,areDatesEqual:y,areErrorsEqual:b,areFunctionsEqual:w,areMapsEqual:r?a(k,A):k,areNumbersEqual:E,areObjectsEqual:r?A:M,arePrimitiveWrappersEqual:_,areRegExpsEqual:x,areSetsEqual:r?a(v,A):v,areTypedArraysEqual:r?a(C,A):C,areUrlsEqual:j,unknownTagComparators:void 0};if(e&&(s=Object.assign({},s,e(s))),t){const t=c(s.areArraysEqual),e=c(s.areMapsEqual),r=c(s.areObjectsEqual),n=c(s.areSetsEqual);s=Object.assign({},s,{areArraysEqual:t,areMapsEqual:e,areObjectsEqual:r,areSetsEqual:n})}return s}(t),i=I(o);var u;return function({circular:t,comparator:e,createState:r,equals:s,strict:n}){if(r)return function(o,i){const{cache:a=(t?new WeakMap:void 0),meta:c}=r();return e(o,i,{cache:a,equals:s,meta:c,strict:n})};if(t)return function(t,r){return e(t,r,{cache:new WeakMap,equals:s,meta:void 0,strict:n})};const o={cache:void 0,equals:s,meta:void 0,strict:n};return function(t,r){return e(t,r,o)}}({circular:e,comparator:i,createState:s,equals:r?r(i):(u=i,function(t,e,r,s,n,o,i){return u(t,e,i)}),strict:n})}S({strict:!0}),S({circular:!0}),S({circular:!0,strict:!0}),S({createInternalComparator:()=>h}),S({strict:!0,createInternalComparator:()=>h}),S({circular:!0,createInternalComparator:()=>h}),S({circular:!0,createInternalComparator:()=>h,strict:!0});const T=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array];class U{static from(t){if(!(t instanceof ArrayBuffer))throw new Error("Data must be an instance of ArrayBuffer.");const[e,r]=new Uint8Array(t,0,2);if(219!==e)throw new Error("Data does not appear to be in a KDBush format.");const s=r>>4;if(1!==s)throw new Error(`Got v${s} data when expected v1.`);const n=T[15&r];if(!n)throw new Error("Unrecognized array type.");const[o]=new Uint16Array(t,2,1),[i]=new Uint32Array(t,4,1);return new U(i,o,n,t)}constructor(t,e=64,r=Float64Array,s){if(isNaN(t)||t<0)throw new Error(`Unpexpected numItems value: ${t}.`);this.numItems=+t,this.nodeSize=Math.min(Math.max(+e,2),65535),this.ArrayType=r,this.IndexArrayType=t<65536?Uint16Array:Uint32Array;const n=T.indexOf(this.ArrayType),o=2*t*this.ArrayType.BYTES_PER_ELEMENT,i=t*this.IndexArrayType.BYTES_PER_ELEMENT,a=(8-i%8)%8;if(n<0)throw new Error(`Unexpected typed array class: ${r}.`);s&&s instanceof ArrayBuffer?(this.data=s,this.ids=new this.IndexArrayType(this.data,8,t),this.coords=new this.ArrayType(this.data,8+i+a,2*t),this._pos=2*t,this._finished=!0):(this.data=new ArrayBuffer(8+o+i+a),this.ids=new this.IndexArrayType(this.data,8,t),this.coords=new this.ArrayType(this.data,8+i+a,2*t),this._pos=0,this._finished=!1,new Uint8Array(this.data,0,2).set([219,16+n]),new Uint16Array(this.data,2,1)[0]=e,new Uint32Array(this.data,4,1)[0]=t)}add(t,e){const r=this._pos>>1;return this.ids[r]=r,this.coords[this._pos++]=t,this.coords[this._pos++]=e,r}finish(){const t=this._pos>>1;if(t!==this.numItems)throw new Error(`Added ${t} items when expected ${this.numItems}.`);return Z(this.ids,this.coords,this.nodeSize,0,this.numItems-1,0),this._finished=!0,this}range(t,e,r,s){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:n,coords:o,nodeSize:i}=this,a=[0,n.length-1,0],c=[];for(;a.length;){const u=a.pop()||0,l=a.pop()||0,h=a.pop()||0;if(l-h<=i){for(let i=h;i<=l;i++){const a=o[2*i],u=o[2*i+1];a>=t&&a<=r&&u>=e&&u<=s&&c.push(n[i])}continue}const p=h+l>>1,f=o[2*p],m=o[2*p+1];f>=t&&f<=r&&m>=e&&m<=s&&c.push(n[p]),(0===u?t<=f:e<=m)&&(a.push(h),a.push(p-1),a.push(1-u)),(0===u?r>=f:s>=m)&&(a.push(p+1),a.push(l),a.push(1-u))}return c}within(t,e,r){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:s,coords:n,nodeSize:o}=this,i=[0,s.length-1,0],a=[],c=r*r;for(;i.length;){const u=i.pop()||0,l=i.pop()||0,h=i.pop()||0;if(l-h<=o){for(let r=h;r<=l;r++)z(n[2*r],n[2*r+1],t,e)<=c&&a.push(s[r]);continue}const p=h+l>>1,f=n[2*p],m=n[2*p+1];z(f,m,t,e)<=c&&a.push(s[p]),(0===u?t-r<=f:e-r<=m)&&(i.push(h),i.push(p-1),i.push(1-u)),(0===u?t+r>=f:e+r>=m)&&(i.push(p+1),i.push(l),i.push(1-u))}return a}}function Z(t,e,r,s,n,o){if(n-s<=r)return;const i=s+n>>1;N(t,e,i,s,n,o),Z(t,e,r,s,i-1,1-o),Z(t,e,r,i+1,n,1-o)}function N(t,e,r,s,n,o){for(;n>s;){if(n-s>600){const i=n-s+1,a=r-s+1,c=Math.log(i),u=.5*Math.exp(2*c/3),l=.5*Math.sqrt(c*u*(i-u)/i)*(a-i/2<0?-1:1);N(t,e,r,Math.max(s,Math.floor(r-a*u/i+l)),Math.min(n,Math.floor(r+(i-a)*u/i+l)),o)}const i=e[2*r+o];let a=s,c=n;for(F(t,e,s,r),e[2*n+o]>i&&F(t,e,s,n);a<c;){for(F(t,e,a,c),a++,c--;e[2*a+o]<i;)a++;for(;e[2*c+o]>i;)c--}e[2*s+o]===i?F(t,e,s,c):(c++,F(t,e,c,n)),c<=r&&(s=c+1),r<=c&&(n=c-1)}}function F(t,e,r,s){B(t,r,s),B(e,2*r,2*s),B(e,2*r+1,2*s+1)}function B(t,e,r){const s=t[e];t[e]=t[r],t[r]=s}function z(t,e,r,s){const n=t-r,o=e-s;return n*n+o*o}const D={minZoom:0,maxZoom:16,minPoints:2,radius:40,extent:512,nodeSize:64,log:!1,generateId:!1,reduce:null,map:t=>t},R=Math.fround||($=new Float32Array(1),t=>($[0]=+t,$[0]));var $;class G{constructor(t){this.options=Object.assign(Object.create(D),t),this.trees=new Array(this.options.maxZoom+1),this.stride=this.options.reduce?7:6,this.clusterProps=[]}load(t){const{log:e,minZoom:r,maxZoom:s}=this.options;t.length;this.points=t;const n=[];for(let e=0;e<t.length;e++){const r=t[e];if(!r.geometry)continue;const[s,o]=r.geometry.coordinates,i=R(W(s)),a=R(J(o));n.push(i,a,1/0,e,-1,1),this.options.reduce&&n.push(0)}let o=this.trees[s+1]=this._createTree(n);for(let t=s;t>=r;t--){Date.now();o=this.trees[t]=this._createTree(this._cluster(o,t))}return this}getClusters(t,e){let r=((t[0]+180)%360+360)%360-180;const s=Math.max(-90,Math.min(90,t[1]));let n=180===t[2]?180:((t[2]+180)%360+360)%360-180;const o=Math.max(-90,Math.min(90,t[3]));if(t[2]-t[0]>=360)r=-180,n=180;else if(r>n){const t=this.getClusters([r,s,180,o],e),i=this.getClusters([-180,s,n,o],e);return t.concat(i)}const i=this.trees[this._limitZoom(e)],a=i.range(W(r),J(o),W(n),J(s)),c=i.data,u=[];for(const t of a){const e=this.stride*t;u.push(c[e+5]>1?V(c,e,this.clusterProps):this.points[c[e+3]])}return u}getChildren(t){const e=this._getOriginId(t),r=this._getOriginZoom(t),s="No cluster with the specified id.",n=this.trees[r];if(!n)throw new Error(s);const o=n.data;if(e*this.stride>=o.length)throw new Error(s);const i=this.options.radius/(this.options.extent*Math.pow(2,r-1)),a=o[e*this.stride],c=o[e*this.stride+1],u=n.within(a,c,i),l=[];for(const e of u){const r=e*this.stride;o[r+4]===t&&l.push(o[r+5]>1?V(o,r,this.clusterProps):this.points[o[r+3]])}if(0===l.length)throw new Error(s);return l}getLeaves(t,e,r){e=e||10,r=r||0;const s=[];return this._appendLeaves(s,t,e,r,0),s}getTile(t,e,r){const s=this.trees[this._limitZoom(t)],n=Math.pow(2,t),{extent:o,radius:i}=this.options,a=i/o,c=(r-a)/n,u=(r+1+a)/n,l={features:[]};return this._addTileFeatures(s.range((e-a)/n,c,(e+1+a)/n,u),s.data,e,r,n,l),0===e&&this._addTileFeatures(s.range(1-a/n,c,1,u),s.data,n,r,n,l),e===n-1&&this._addTileFeatures(s.range(0,c,a/n,u),s.data,-1,r,n,l),l.features.length?l:null}getClusterExpansionZoom(t){let e=this._getOriginZoom(t)-1;for(;e<=this.options.maxZoom;){const r=this.getChildren(t);if(e++,1!==r.length)break;t=r[0].properties.cluster_id}return e}_appendLeaves(t,e,r,s,n){const o=this.getChildren(e);for(const e of o){const o=e.properties;if(o&&o.cluster?n+o.point_count<=s?n+=o.point_count:n=this._appendLeaves(t,o.cluster_id,r,s,n):n<s?n++:t.push(e),t.length===r)break}return n}_createTree(t){const e=new U(t.length/this.stride|0,this.options.nodeSize,Float32Array);for(let r=0;r<t.length;r+=this.stride)e.add(t[r],t[r+1]);return e.finish(),e.data=t,e}_addTileFeatures(t,e,r,s,n,o){for(const i of t){const t=i*this.stride,a=e[t+5]>1;let c,u,l;if(a)c=K(e,t,this.clusterProps),u=e[t],l=e[t+1];else{const r=this.points[e[t+3]];c=r.properties;const[s,n]=r.geometry.coordinates;u=W(s),l=J(n)}const h={type:1,geometry:[[Math.round(this.options.extent*(u*n-r)),Math.round(this.options.extent*(l*n-s))]],tags:c};let p;p=a||this.options.generateId?e[t+3]:this.points[e[t+3]].id,void 0!==p&&(h.id=p),o.features.push(h)}}_limitZoom(t){return Math.max(this.options.minZoom,Math.min(Math.floor(+t),this.options.maxZoom+1))}_cluster(t,e){const{radius:r,extent:s,reduce:n,minPoints:o}=this.options,i=r/(s*Math.pow(2,e)),a=t.data,c=[],u=this.stride;for(let r=0;r<a.length;r+=u){if(a[r+2]<=e)continue;a[r+2]=e;const s=a[r],l=a[r+1],h=t.within(a[r],a[r+1],i),p=a[r+5];let f=p;for(const t of h){const r=t*u;a[r+2]>e&&(f+=a[r+5])}if(f>p&&f>=o){let t,o=s*p,i=l*p,m=-1;const d=(r/u<<5)+(e+1)+this.points.length;for(const s of h){const c=s*u;if(a[c+2]<=e)continue;a[c+2]=e;const l=a[c+5];o+=a[c]*l,i+=a[c+1]*l,a[c+4]=d,n&&(t||(t=this._map(a,r,!0),m=this.clusterProps.length,this.clusterProps.push(t)),n(t,this._map(a,c)))}a[r+4]=d,c.push(o/f,i/f,1/0,d,-1,f),n&&c.push(m)}else{for(let t=0;t<u;t++)c.push(a[r+t]);if(f>1)for(const t of h){const r=t*u;if(!(a[r+2]<=e)){a[r+2]=e;for(let t=0;t<u;t++)c.push(a[r+t])}}}}return c}_getOriginId(t){return t-this.points.length>>5}_getOriginZoom(t){return(t-this.points.length)%32}_map(t,e,r){if(t[e+5]>1){const s=this.clusterProps[t[e+6]];return r?Object.assign({},s):s}const s=this.points[t[e+3]].properties,n=this.options.map(s);return r&&n===s?Object.assign({},n):n}}function V(t,e,r){return{type:"Feature",id:t[e+3],properties:K(t,e,r),geometry:{type:"Point",coordinates:[(s=t[e],360*(s-.5)),X(t[e+1])]}};var s}function K(t,e,r){const s=t[e+5],n=s>=1e4?`${Math.round(s/1e3)}k`:s>=1e3?Math.round(s/100)/10+"k":s,o=t[e+6],i=-1===o?{}:Object.assign({},r[o]);return Object.assign(i,{cluster:!0,cluster_id:t[e+3],point_count:s,point_count_abbreviated:n})}function W(t){return t/360+.5}function J(t){const e=Math.sin(t*Math.PI/180),r=.5-.25*Math.log((1+e)/(1-e))/Math.PI;return r<0?0:r>1?1:r}function X(t){const e=(180-360*t)*Math.PI/180;return 360*Math.atan(Math.exp(e))/Math.PI-90}"function"==typeof SuppressedError&&SuppressedError;class Y{static isAdvancedMarkerAvailable(t){return google.maps.marker&&!0===t.getMapCapabilities().isAdvancedMarkersAvailable}static isAdvancedMarker(t){return google.maps.marker&&t instanceof google.maps.marker.AdvancedMarkerElement}static setMap(t,e){this.isAdvancedMarker(t)?t.map=e:t.setMap(e)}static getPosition(t){if(this.isAdvancedMarker(t)){if(t.position){if(t.position instanceof google.maps.LatLng)return t.position;if(Number.isFinite(t.position.lat)&&Number.isFinite(t.position.lng))return new google.maps.LatLng(t.position.lat,t.position.lng)}return new google.maps.LatLng(null)}return t.getPosition()}static getVisible(t){return!!this.isAdvancedMarker(t)||t.getVisible()}}class H{constructor({markers:t,position:e}){this.markers=[],t&&(this.markers=t),e&&(e instanceof google.maps.LatLng?this._position=e:this._position=new google.maps.LatLng(e))}get bounds(){if(0===this.markers.length&&!this._position)return;const t=new google.maps.LatLngBounds(this._position,this._position);for(const e of this.markers)t.extend(Y.getPosition(e));return t}get position(){return this._position||this.bounds.getCenter()}get count(){return this.markers.filter(t=>Y.getVisible(t)).length}push(t){this.markers.push(t)}delete(){this.marker&&(Y.setMap(this.marker,null),this.marker=void 0),this.markers.length=0}}function Q(t,e="assertion failed"){if(null==t)throw Error(e)}class tt{constructor({maxZoom:t=16}){this.maxZoom=t}noop({markers:t}){return et(t)}}const et=t=>t.map(t=>new H({position:Y.getPosition(t),markers:[t]}));class rt extends tt{constructor(t){var{maxZoom:e,radius:r=60}=t,s=function(t,e){var r={};for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&e.indexOf(s)<0&&(r[s]=t[s]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var n=0;for(s=Object.getOwnPropertySymbols(t);n<s.length;n++)e.indexOf(s[n])<0&&Object.prototype.propertyIsEnumerable.call(t,s[n])&&(r[s[n]]=t[s[n]])}return r}(t,["maxZoom","radius"]);super({maxZoom:e}),this.markers=[],this.clusters=[],this.state={zoom:-1},this.superCluster=new G(Object.assign({maxZoom:this.maxZoom,radius:r},s))}calculate(t){let e=!1,r=t.map.getZoom();Q(r),r=Math.round(r);const s={zoom:r};if(!P(t.markers,this.markers)){e=!0,this.markers=[...t.markers];const r=this.markers.map(t=>{const e=Y.getPosition(t);return{type:"Feature",geometry:{type:"Point",coordinates:[e.lng(),e.lat()]},properties:{marker:t}}});this.superCluster.load(r)}return e||(this.state.zoom<=this.maxZoom||s.zoom<=this.maxZoom)&&(e=!P(this.state,s)),this.state=s,0===t.markers.length?(this.clusters=[],{clusters:this.clusters,changed:e}):(e&&(this.clusters=this.cluster(t)),{clusters:this.clusters,changed:e})}cluster({map:t}){const e=t.getZoom();return Q(e),this.superCluster.getClusters([-180,-90,180,90],Math.round(e)).map(t=>this.transformCluster(t))}transformCluster({geometry:{coordinates:[t,e]},properties:r}){if(r.cluster)return new H({markers:this.superCluster.getLeaves(r.cluster_id,1/0).map(t=>t.properties.marker),position:{lat:e,lng:t}});const s=r.marker;return new H({markers:[s],position:Y.getPosition(s)})}}class st{constructor(t,e){this.markers={sum:t.length};const r=e.map(t=>t.count),s=r.reduce((t,e)=>t+e,0);this.clusters={count:e.length,markers:{mean:s/e.length,sum:s,min:Math.min(...r),max:Math.max(...r)}}}}class nt{render({count:t,position:e},r,s){const n=`<svg fill="${t>Math.max(10,r.clusters.markers.mean)?"#ff0000":"#0000ff"}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">\n<circle cx="120" cy="120" opacity=".6" r="70" />\n<circle cx="120" cy="120" opacity=".3" r="90" />\n<circle cx="120" cy="120" opacity=".2" r="110" />\n<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">${t}</text>\n</svg>`,o=`Cluster of ${t} markers`,i=Number(google.maps.Marker.MAX_ZINDEX)+t;if(Y.isAdvancedMarkerAvailable(s)){const t=(new DOMParser).parseFromString(n,"image/svg+xml").documentElement;t.setAttribute("transform","translate(0 25)");const r={map:s,position:e,zIndex:i,title:o,content:t};return new google.maps.marker.AdvancedMarkerElement(r)}const a={position:e,zIndex:i,title:o,icon:{url:`data:image/svg+xml;base64,${btoa(n)}`,anchor:new google.maps.Point(25,25)}};return new google.maps.Marker(a)}}class ot{constructor(){!function(t,e){for(let r in e.prototype)t.prototype[r]=e.prototype[r]}(ot,google.maps.OverlayView)}}var it;!function(t){t.CLUSTERING_BEGIN="clusteringbegin",t.CLUSTERING_END="clusteringend",t.CLUSTER_CLICK="click",t.GMP_CLICK="gmp-click"}(it||(it={}));const at=(t,e,r)=>{e.bounds&&r.fitBounds(e.bounds)};class ct extends ot{constructor({map:t,markers:e=[],algorithmOptions:r={},algorithm:s=new rt(r),renderer:n=new nt,onClusterClick:o=at}){super(),this.map=null,this.idleListener=null,this.markers=[...e],this.clusters=[],this.algorithm=s,this.renderer=n,this.onClusterClick=o,t&&this.setMap(t)}addMarker(t,e){this.markers.includes(t)||(this.markers.push(t),e||this.render())}addMarkers(t,e){t.forEach(t=>{this.addMarker(t,!0)}),e||this.render()}removeMarker(t,e){const r=this.markers.indexOf(t);return-1!==r&&(Y.setMap(t,null),this.markers.splice(r,1),e||this.render(),!0)}removeMarkers(t,e){let r=!1;return t.forEach(t=>{r=this.removeMarker(t,!0)||r}),r&&!e&&this.render(),r}clearMarkers(t){this.markers.length=0,t||this.render()}render(){const t=this.getMap();if(t instanceof google.maps.Map&&t.getProjection()){google.maps.event.trigger(this,it.CLUSTERING_BEGIN,this);const{clusters:e,changed:r}=this.algorithm.calculate({markers:this.markers,map:t,mapCanvasProjection:this.getProjection()});if(r||null==r){const t=new Set;for(const r of e)1==r.markers.length&&t.add(r.markers[0]);const r=[];for(const e of this.clusters)null!=e.marker&&(1==e.markers.length?t.has(e.marker)||Y.setMap(e.marker,null):r.push(e.marker));this.clusters=e,this.renderClusters(),requestAnimationFrame(()=>r.forEach(t=>Y.setMap(t,null)))}google.maps.event.trigger(this,it.CLUSTERING_END,this)}}onAdd(){const t=this.getMap();Q(t),this.idleListener=t.addListener("idle",this.render.bind(this)),this.render()}onRemove(){this.idleListener&&google.maps.event.removeListener(this.idleListener),this.reset()}reset(){this.markers.forEach(t=>Y.setMap(t,null)),this.clusters.forEach(t=>t.delete()),this.clusters=[]}renderClusters(){const t=new st(this.markers,this.clusters),e=this.getMap();this.clusters.forEach(r=>{if(1===r.markers.length)r.marker=r.markers[0];else if(r.marker=this.renderer.render(r,t,e),r.markers.forEach(t=>Y.setMap(t,null)),this.onClusterClick){const t=Y.isAdvancedMarker(r.marker)?it.GMP_CLICK:it.CLUSTER_CLICK;r.marker.addListener(t,t=>{google.maps.event.trigger(this,it.CLUSTER_CLICK,r),this.onClusterClick(t,r,e)})}Y.setMap(r.marker,e)})}}export{ct as M,rt as S,s as i,r as s};
